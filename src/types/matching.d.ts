/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/v1/match/enqueue": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Enqueue a match request */
    post: operations["enqueueMatch"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v1/match/cancel": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Cancel a pending match request */
    post: operations["cancelMatch"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v1/match/tick": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Advance matching loop (scheduler hook) */
    post: operations["processTick"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    GeoPoint: {
      lat: number;
      lon: number;
    };
    MatchPreferences: {
      /** @enum {string} */
      intent: "incident" | "route" | "social" | "coach";
      radiusKm: number;
      mood?: string;
      trafficLevel?: string;
      locale: string;
      allowVoiceOnly?: boolean;
    };
    CapabilityFlags: {
      mic?: boolean;
      text?: boolean;
      shareLocation?: boolean;
    };
    MatchRequest: {
      requestId: string;
      userId: string;
      /** @description Opaque snapshot of the user profile at request time */
      profileSnapshot: {
        [key: string]: unknown;
      };
      geoHash: string;
      coordinates: components["schemas"]["GeoPoint"];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      expiresAt: string;
      preferences: components["schemas"]["MatchPreferences"];
      capabilities: components["schemas"]["CapabilityFlags"];
      reputationScore: number;
    };
    QueueSlot: {
      request: components["schemas"]["MatchRequest"];
      /** Format: date-time */
      enqueuedAt: string;
      priority: number;
    };
    Error: {
      code: string;
      message: string;
      details?: {
        [key: string]: unknown;
      };
    };
  };
  responses: {
    /** @description Input validation failed */
    BadRequest: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Resource not found */
    NotFound: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  enqueueMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MatchRequest"];
      };
    };
    responses: {
      /** @description Accepted into queue */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["QueueSlot"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  cancelMatch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          requestId: string;
          userId: string;
        };
      };
    };
    responses: {
      /** @description Cancelled */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      404: components["responses"]["NotFound"];
    };
  };
  processTick: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Tick processed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            matchedCount?: number;
            expandedCount?: number;
            queueDepth?: number;
          };
        };
      };
    };
  };
}
